<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/launsh.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/launsh.json" />
              <option name="updatedContent" value="{&#10;  &quot;executions&quot;: {&#10;    &quot;hello_world&quot;: {&#10;      &quot;description&quot;: &quot;Prints Hello World to the console.&quot;,&#10;      &quot;program&quot;: &quot;echo&quot;,&#10;      &quot;args&quot;: [&quot;Hello World!&quot;],&#10;      &quot;variable&quot;: [],&#10;      &quot;environment&quot;: {}&#10;    },&#10;    &quot;list_files&quot;: {&#10;      &quot;description&quot;: &quot;Lists files in the current directory.&quot;,&#10;      &quot;program&quot;: &quot;ls&quot;,&#10;      &quot;args&quot;: [&quot;-l&quot;],&#10;      &quot;variable&quot;: [],&#10;      &quot;environment&quot;: {}&#10;    },&#10;    &quot;custom_greet&quot;: {&#10;      &quot;description&quot;: &quot;Greets a user by name.&quot;,&#10;      &quot;program&quot;: &quot;echo&quot;,&#10;      &quot;args&quot;: [],&#10;      &quot;variable&quot;: [&quot;name&quot;],&#10;      &quot;environment&quot;: {}&#10;    }&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/component/execution_entry.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/component/execution_entry.dart" />
              <option name="originalContent" value="import 'dart:convert';&#10;import 'dart:io';&#10;&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/component/run_dialog.dart';&#10;import 'package:launsh/schema/execution.dart';&#10;import 'package:path/path.dart' as path;&#10;&#10;// Callback type for logging messages.&#10;typedef LogCallback = void Function(String message);&#10;&#10;class ExecutionEntry extends StatefulWidget {&#10;  final String configDir;&#10;  final String name;&#10;  final Execution execution;&#10;  final LogCallback onLog; // Callback to send logs to the parent.&#10;&#10;  const ExecutionEntry({&#10;    super.key,&#10;    required this.configDir,&#10;    required this.name,&#10;    required this.execution,&#10;    required this.onLog,&#10;  });&#10;&#10;  @override&#10;  State&lt;ExecutionEntry&gt; createState() =&gt; _ExecutionEntryState();&#10;}&#10;&#10;class _ExecutionEntryState extends State&lt;ExecutionEntry&gt; {&#10;  late final Map&lt;String, TextEditingController&gt; _variableControllers;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    _variableControllers = {&#10;      for (final v in widget.execution.variable) v: TextEditingController(),&#10;    };&#10;  }&#10;&#10;  @override&#10;  void dispose() {&#10;    for (final controller in _variableControllers.values) {&#10;      controller.dispose();&#10;    }&#10;    super.dispose();&#10;  }&#10;&#10;  String get _interpolatedCommand {&#10;    return '${widget.execution.program} ${widget.execution.args.join(' ')}';&#10;  }&#10;&#10;  Future&lt;void&gt; _confirmAndRunExecution(BuildContext context) async {&#10;    final confirmed = await showDialog&lt;bool&gt;(&#10;      context: context,&#10;      builder: (context) =&gt; RunDialog(&#10;        command: _interpolatedCommand,&#10;        variableNames: widget.execution.variable,&#10;        variableControllers: _variableControllers,&#10;      ),&#10;    );&#10;    if (confirmed == true) {&#10;      await _runExecution();&#10;    }&#10;  }&#10;&#10;  Future&lt;void&gt; _runExecution() async {&#10;    widget.onLog('Running command: $_interpolatedCommand');&#10;    final execution = widget.execution;&#10;    final workingDir = path.join(widget.configDir, execution.workingDir);&#10;&#10;    try {&#10;      final variables = {&#10;        for (final e in _variableControllers.entries) e.key: e.value.text,&#10;      };&#10;      final stdout = execution.stdout == null ? null : path.join(workingDir, execution.stdout);&#10;      final stderr = execution.stderr == null ? null : path.join(workingDir, execution.stderr);&#10;      if (stdout != null) {&#10;        File(stdout).createSync(recursive: true);&#10;      }&#10;      if (stderr != null) {&#10;        File(stderr).createSync(recursive: true);&#10;      }&#10;&#10;      final process = await Process.start(&#10;        execution.program,&#10;        execution.args,&#10;        workingDirectory: workingDir,&#10;        environment: execution.environment..addEntries(variables.entries),&#10;        runInShell: true,&#10;      );&#10;&#10;      process.stdout.transform(utf8.decoder).listen((data) {&#10;        if (data.trim().isNotEmpty) widget.onLog('STDOUT: ${data.trim()}');&#10;        if (stdout != null) {&#10;          File(stdout).writeAsStringSync(data, mode: FileMode.writeOnlyAppend);&#10;        }&#10;      });&#10;&#10;      process.stderr.transform(utf8.decoder).listen((data) {&#10;        if (data.trim().isNotEmpty) widget.onLog('STDERR: ${data.trim()}');&#10;        if (stderr != null) {&#10;          File(stderr).writeAsStringSync(data, mode: FileMode.writeOnlyAppend);&#10;        }&#10;      });&#10;&#10;      final exitCode = await process.exitCode;&#10;      widget.onLog('Process exited with code $exitCode');&#10;    } catch (e) {&#10;      widget.onLog('Failed to run command: $e');&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Card(&#10;      margin: const EdgeInsets.symmetric(vertical: 8),&#10;      child: Padding(&#10;        padding: const EdgeInsets.all(12.0),&#10;        child: Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Row(&#10;              children: [&#10;                Tooltip(&#10;                  message: widget.execution.description ?? '',&#10;                  child: Text(&#10;                    widget.name,&#10;                    style: const TextStyle(&#10;                      fontSize: 18,&#10;                      fontWeight: FontWeight.bold,&#10;                    ),&#10;                  ),&#10;                ),&#10;                const Spacer(),&#10;                ElevatedButton.icon(&#10;                  icon: const Icon(Icons.play_arrow),&#10;                  label: const Text('Run'),&#10;                  onPressed: () =&gt; _confirmAndRunExecution(context),&#10;                ),&#10;              ],&#10;            ),&#10;            const SizedBox(height: 4),&#10;            Text(&#10;              _interpolatedCommand,&#10;              style: TextStyle(&#10;                fontFamily: 'monospace',&#10;                color: Colors.grey.shade700,&#10;              ),&#10;            ),&#10;          ],&#10;        ),&#10;      ),&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'dart:convert';&#10;import 'dart:io';&#10;&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/component/run_dialog.dart';&#10;import 'package:launsh/schema/execution.dart';&#10;import 'package:path/path.dart' as path;&#10;&#10;// Callback type for logging messages.&#10;typedef LogCallback = void Function(String message);&#10;&#10;class ExecutionEntry extends StatefulWidget {&#10;  final String configDir;&#10;  final String name;&#10;  final Execution execution;&#10;  final LogCallback onLog; // Callback to send logs to the parent.&#10;&#10;  const ExecutionEntry({&#10;    super.key,&#10;    required this.configDir,&#10;    required this.name,&#10;    required this.execution,&#10;    required this.onLog,&#10;  });&#10;&#10;  @override&#10;  State&lt;ExecutionEntry&gt; createState() =&gt; _ExecutionEntryState();&#10;}&#10;&#10;class _ExecutionEntryState extends State&lt;ExecutionEntry&gt; {&#10;  late final Map&lt;String, TextEditingController&gt; _variableControllers;&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    _variableControllers = {&#10;      for (final v in widget.execution.variable) v: TextEditingController(),&#10;    };&#10;  }&#10;&#10;  @override&#10;  void dispose() {&#10;    for (final controller in _variableControllers.values) {&#10;      controller.dispose();&#10;    }&#10;    super.dispose();&#10;  }&#10;&#10;  String get _interpolatedCommand {&#10;    return '${widget.execution.program} ${widget.execution.args.join(' ')}';&#10;  }&#10;&#10;  Future&lt;void&gt; _confirmAndRunExecution(BuildContext context) async {&#10;    final confirmed = await showDialog&lt;bool&gt;(&#10;      context: context,&#10;      builder: (context) =&gt; RunDialog(&#10;        command: _interpolatedCommand,&#10;        variableNames: widget.execution.variable,&#10;        variableControllers: _variableControllers,&#10;      ),&#10;    );&#10;    if (confirmed == true) {&#10;      await _runExecution();&#10;    }&#10;  }&#10;&#10;  Future&lt;void&gt; _runExecution() async {&#10;    widget.onLog('Running command: $_interpolatedCommand');&#10;    final execution = widget.execution;&#10;    final workingDir = path.join(widget.configDir, execution.workingDir);&#10;&#10;    try {&#10;      final variables = {&#10;        for (final e in _variableControllers.entries) e.key: e.value.text,&#10;      };&#10;      final stdout = execution.stdout == null ? null : path.join(workingDir, execution.stdout);&#10;      final stderr = execution.stderr == null ? null : path.join(workingDir, execution.stderr);&#10;      if (stdout != null) {&#10;        File(stdout).createSync(recursive: true);&#10;      }&#10;      if (stderr != null) {&#10;        File(stderr).createSync(recursive: true);&#10;      }&#10;&#10;      final process = await Process.start(&#10;        execution.program,&#10;        execution.args,&#10;        workingDirectory: workingDir,&#10;        environment: execution.environment..addEntries(variables.entries),&#10;        runInShell: true,&#10;      );&#10;&#10;      process.stdout.transform(utf8.decoder).listen((data) {&#10;        if (data.trim().isNotEmpty) widget.onLog('STDOUT: ${data.trim()}');&#10;        if (stdout != null) {&#10;          File(stdout).writeAsStringSync(data, mode: FileMode.writeOnlyAppend);&#10;        }&#10;      });&#10;&#10;      process.stderr.transform(utf8.decoder).listen((data) {&#10;        if (data.trim().isNotEmpty) widget.onLog('STDERR: ${data.trim()}');&#10;        if (stderr != null) {&#10;          File(stderr).writeAsStringSync(data, mode: FileMode.writeOnlyAppend);&#10;        }&#10;      });&#10;&#10;      final exitCode = await process.exitCode;&#10;      widget.onLog('Process exited with code $exitCode');&#10;    } catch (e) {&#10;      widget.onLog('Failed to run command: $e');&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Card(&#10;      margin: const EdgeInsets.symmetric(vertical: 8),&#10;      child: Padding(&#10;        padding: const EdgeInsets.all(12.0),&#10;        child: Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Row(&#10;              children: [&#10;                Tooltip(&#10;                  message: widget.execution.description ?? '',&#10;                  child: Text(&#10;                    widget.name,&#10;                    style: const TextStyle(&#10;                      fontSize: 18,&#10;                      fontWeight: FontWeight.bold,&#10;                    ),&#10;                  ),&#10;                ),&#10;                const Spacer(),&#10;                ElevatedButton.icon(&#10;                  icon: const Icon(Icons.play_arrow),&#10;                  label: const Text('Run'),&#10;                  onPressed: () =&gt; _confirmAndRunExecution(context),&#10;                ),&#10;              ],&#10;            ),&#10;            const SizedBox(height: 4),&#10;            Text(&#10;              _interpolatedCommand,&#10;              style: TextStyle(&#10;                fontFamily: 'monospace',&#10;                color: Colors.grey.shade700,&#10;              ),&#10;            ),&#10;          ],&#10;        ),&#10;      ),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/component/execution_log.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/component/execution_log.dart" />
              <option name="originalContent" value="// lib/component/execution_log.dart&#10;&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/component/execution_log_controller.dart';&#10;&#10;class ExecutionLog extends StatelessWidget {&#10;  final ExecutionLogController controller;&#10;&#10;  const ExecutionLog({super.key, required this.controller});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return AnimatedBuilder(&#10;      animation: controller,&#10;      builder: (context, _) {&#10;        return Expanded(&#10;          child: Column(&#10;            crossAxisAlignment: CrossAxisAlignment.start,&#10;            children: [&#10;              const Text(&#10;                'Execution Log',&#10;                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),&#10;              ),&#10;              const SizedBox(height: 8),&#10;              Expanded(&#10;                child: Container(&#10;                  width: double.infinity,&#10;                  padding: const EdgeInsets.all(8.0),&#10;                  decoration: BoxDecoration(&#10;                    border: Border.all(color: Colors.grey.shade400),&#10;                    borderRadius: BorderRadius.circular(4.0),&#10;                    color: Colors.grey.shade100,&#10;                  ),&#10;                  child: SingleChildScrollView(&#10;                    reverse: true,&#10;                    child: Text(controller.log),&#10;                  ),&#10;                ),&#10;              ),&#10;            ],&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="// lib/component/execution_log.dart&#10;&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/component/execution_log_controller.dart';&#10;&#10;class ExecutionLog extends StatelessWidget {&#10;  final ExecutionLogController controller;&#10;&#10;  const ExecutionLog({super.key, required this.controller});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return AnimatedBuilder(&#10;      animation: controller,&#10;      builder: (context, _) {&#10;        return Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            const Text(&#10;              'Execution Log',&#10;              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),&#10;            ),&#10;            const SizedBox(height: 8),&#10;            Expanded(&#10;              child: Container(&#10;                width: double.infinity,&#10;                padding: const EdgeInsets.all(8.0),&#10;                decoration: BoxDecoration(&#10;                  border: Border.all(color: Colors.grey.shade400),&#10;                  borderRadius: BorderRadius.circular(4.0),&#10;                  color: Colors.grey.shade100,&#10;                ),&#10;                child: SingleChildScrollView(&#10;                  reverse: true,&#10;                  child: Text(controller.log),&#10;                ),&#10;              ),&#10;            ),&#10;          ],&#10;        );&#10;      },&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/component/execution_log_controller.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/component/execution_log_controller.dart" />
              <option name="updatedContent" value="import 'package:flutter/foundation.dart';&#10;&#10;class ExecutionLogController extends ChangeNotifier {&#10;  final StringBuffer _buffer = StringBuffer();&#10;&#10;  String get log =&gt; _buffer.toString();&#10;&#10;  void add(String message) {&#10;    _buffer.writeln('[${DateTime.now().toIso8601String()}] $message');&#10;    notifyListeners();&#10;  }&#10;&#10;  void clear() {&#10;    _buffer.clear();&#10;    notifyListeners();&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/component/launsh_page.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/component/launsh_page.dart" />
              <option name="originalContent" value="import 'package:file_picker/file_picker.dart';&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/component/execution_list.dart';&#10;import 'package:launsh/component/execution_log.dart';&#10;import 'package:launsh/component/execution_log_controller.dart';&#10;&#10;class LaunshPage extends StatefulWidget {&#10;  const LaunshPage({super.key});&#10;&#10;  @override&#10;  State&lt;LaunshPage&gt; createState() =&gt; _LaunshPageState();&#10;}&#10;&#10;class _LaunshPageState extends State&lt;LaunshPage&gt; {&#10;  String? _configFilePath;&#10;  final ExecutionLogController _logController = ExecutionLogController();&#10;&#10;  Future&lt;void&gt; _pickAndLoadFile() async {&#10;    final result = await FilePicker.platform.pickFiles(&#10;      type: FileType.custom,&#10;      allowedExtensions: ['json'],&#10;    );&#10;&#10;    if (result != null &amp;&amp; result.files.single.path != null) {&#10;      final path = result.files.single.path!;&#10;      try {&#10;        setState(() {&#10;          _configFilePath = path;&#10;          _logController.clear();&#10;          _logController.add('Loaded configuration from: $path');&#10;        });&#10;      } catch (e) {&#10;        _logController.add('Error loading or parsing config file: $e');&#10;      }&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(title: const Text('Launsh GUI')),&#10;      body: Column(&#10;        children: [&#10;          Padding(&#10;            padding: const EdgeInsets.all(16.0),&#10;            child: Row(&#10;              children: [&#10;                ElevatedButton.icon(&#10;                  icon: const Icon(Icons.folder_open),&#10;                  onPressed: _pickAndLoadFile,&#10;                  label: const Text('Select Config File'),&#10;                ),&#10;                const SizedBox(width: 16),&#10;                Expanded(&#10;                  child: Text(&#10;                    _configFilePath ?? 'No file selected',&#10;                    style: const TextStyle(fontStyle: FontStyle.italic),&#10;                    overflow: TextOverflow.ellipsis,&#10;                  ),&#10;                ),&#10;              ],&#10;            ),&#10;          ),&#10;          const Divider(),&#10;          Expanded(&#10;            flex: 3,&#10;            child: ExecutionList(&#10;              configFilePath: _configFilePath,&#10;              onLog: _logController.add,&#10;            ),&#10;          ),&#10;          const SizedBox(height: 16),&#10;          Expanded(flex: 2, child: ExecutionLog(controller: _logController)),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'package:file_picker/file_picker.dart';&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/component/execution_list.dart';&#10;import 'package:launsh/component/execution_log.dart';&#10;import 'package:launsh/component/execution_log_controller.dart';&#10;&#10;class LaunshPage extends StatefulWidget {&#10;  const LaunshPage({super.key});&#10;&#10;  @override&#10;  State&lt;LaunshPage&gt; createState() =&gt; _LaunshPageState();&#10;}&#10;&#10;class _LaunshPageState extends State&lt;LaunshPage&gt; {&#10;  String? _configFilePath;&#10;  final ExecutionLogController _logController = ExecutionLogController();&#10;&#10;  Future&lt;void&gt; _pickAndLoadFile() async {&#10;    final result = await FilePicker.platform.pickFiles(&#10;      type: FileType.custom,&#10;      allowedExtensions: ['json'],&#10;    );&#10;&#10;    if (result != null &amp;&amp; result.files.single.path != null) {&#10;      final path = result.files.single.path!;&#10;      try {&#10;        setState(() {&#10;          _configFilePath = path;&#10;          _logController.clear();&#10;          _logController.add('Loaded configuration from: $path');&#10;        });&#10;      } catch (e) {&#10;        _logController.add('Error loading or parsing config file: $e');&#10;      }&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(title: const Text('Launsh GUI')),&#10;      body: Column(&#10;        children: [&#10;          Padding(&#10;            padding: const EdgeInsets.all(16.0),&#10;            child: Row(&#10;              children: [&#10;                ElevatedButton.icon(&#10;                  icon: const Icon(Icons.folder_open),&#10;                  onPressed: _pickAndLoadFile,&#10;                  label: const Text('Select Config File'),&#10;                ),&#10;                const SizedBox(width: 16),&#10;                Expanded(&#10;                  child: Text(&#10;                    _configFilePath ?? 'No file selected',&#10;                    style: const TextStyle(fontStyle: FontStyle.italic),&#10;                    overflow: TextOverflow.ellipsis,&#10;                  ),&#10;                ),&#10;                if (_configFilePath != null)&#10;                  IconButton(&#10;                    icon: const Icon(Icons.refresh),&#10;                    tooltip: 'Reload config file',&#10;                    onPressed: () {&#10;                      // Re-run the file load logic&#10;                      if (_configFilePath != null) {&#10;                        setState(() {&#10;                          _logController.clear();&#10;                          _logController.add('Reloaded configuration from: $_configFilePath');&#10;                        });&#10;                      }&#10;                    },&#10;                  ),&#10;              ],&#10;            ),&#10;          ),&#10;          const Divider(),&#10;          Expanded(&#10;            flex: 3,&#10;            child: ExecutionList(&#10;              configFilePath: _configFilePath,&#10;              onLog: _logController.add,&#10;            ),&#10;          ),&#10;          const SizedBox(height: 16),&#10;          Expanded(flex: 2, child: ExecutionLog(controller: _logController)),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/component/run_dialog.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/component/run_dialog.dart" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;&#10;class RunDialog extends StatelessWidget {&#10;  final String command;&#10;  final List&lt;String&gt; variableNames;&#10;  final Map&lt;String, TextEditingController&gt; variableControllers;&#10;&#10;  const RunDialog({&#10;    super.key,&#10;    required this.command,&#10;    required this.variableNames,&#10;    required this.variableControllers,&#10;  });&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return AlertDialog(&#10;      title: const Text('Confirm Execution'),&#10;      content: SizedBox(&#10;        width: 500,&#10;        child: SingleChildScrollView(&#10;          child: Column(&#10;            mainAxisSize: MainAxisSize.min,&#10;            crossAxisAlignment: CrossAxisAlignment.start,&#10;            children: [&#10;              Text('Run the following command?'),&#10;              const SizedBox(height: 8),&#10;              Text(command, style: const TextStyle(fontFamily: 'monospace')),&#10;              if (variableNames.isNotEmpty) ...[&#10;                const SizedBox(height: 16),&#10;                const Text('Set variables:'),&#10;                ...variableNames.map((v) =&gt; Padding(&#10;                  padding: const EdgeInsets.symmetric(vertical: 4.0),&#10;                  child: TextField(&#10;                    controller: variableControllers[v],&#10;                    decoration: InputDecoration(labelText: v),&#10;                  ),&#10;                )),&#10;              ],&#10;            ],&#10;          ),&#10;        ),&#10;      ),&#10;      actions: [&#10;        TextButton(&#10;          onPressed: () =&gt; Navigator.of(context).pop(false),&#10;          child: const Text('Cancel'),&#10;        ),&#10;        ElevatedButton(&#10;          onPressed: () =&gt; Navigator.of(context).pop(true),&#10;          child: const Text('Run'),&#10;        ),&#10;      ],&#10;    );&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/execution.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/execution.dart" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import 'dart:convert';&#10;import 'dart:io';&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/schema/execution.dart';&#10;&#10;class ExecutionEntry extends StatelessWidget {&#10;  final String name;&#10;  final Execution execution;&#10;  final Map&lt;String, TextEditingController&gt; controllers;&#10;&#10;  const ExecutionEntry({&#10;    super.key,&#10;    required this.name,&#10;    required this.execution,&#10;    required this.controllers,&#10;  });&#10;&#10;  Future&lt;void&gt; _confirmAndRunExecution(BuildContext context) async {&#10;    final variableValues = &lt;String, String&gt;{};&#10;    for (final v in execution.variable) {&#10;      variableValues[v] = controllers[v]?.text ?? '';&#10;    }&#10;    final command = _buildCommand(variableValues);&#10;    final confirmed = await showDialog&lt;bool&gt;(&#10;      context: context,&#10;      builder: (context) =&gt; AlertDialog(&#10;        title: const Text('Confirm Execution'),&#10;        content: Text('Run the following command?\n\n$command'),&#10;        actions: [&#10;          TextButton(&#10;            onPressed: () =&gt; Navigator.of(context).pop(false),&#10;            child: const Text('Cancel'),&#10;          ),&#10;          ElevatedButton(&#10;            onPressed: () =&gt; Navigator.of(context).pop(true),&#10;            child: const Text('Run'),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;    if (confirmed == true) {&#10;      await _runExecution(variableValues);&#10;    }&#10;  }&#10;&#10;  String _buildCommand(Map&lt;String, String&gt; variableValues) {&#10;    String cmd = execution.program;&#10;    if (execution.args.isNotEmpty) {&#10;      cmd += ' ' + execution.args.join(' ');&#10;    }&#10;    if (variableValues.isNotEmpty) {&#10;      cmd += ' ' + variableValues.entries.map((e) =&gt; '${e.key}=${e.value}').join(' ');&#10;    }&#10;    return cmd;&#10;  }&#10;&#10;  Future&lt;void&gt; _runExecution(Map&lt;String, String&gt; variableValues) async {&#10;    // You may want to send logs to ExecutionLog via a callback or a global state&#10;    try {&#10;      final process = await Process.start(&#10;        execution.program,&#10;        execution.args + variableValues.values.toList(),&#10;        workingDirectory: execution.workingDir,&#10;        environment: execution.environment,&#10;        runInShell: true,&#10;      );&#10;      process.stdout.transform(utf8.decoder).listen((data) {&#10;        // Send log to ExecutionLog&#10;      });&#10;      process.stderr.transform(utf8.decoder).listen((data) {&#10;        // Send log to ExecutionLog&#10;      });&#10;      final exitCode = await process.exitCode;&#10;      // Send log to ExecutionLog&#10;    } catch (e) {&#10;      // Send log to ExecutionLog&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Card(&#10;      margin: const EdgeInsets.symmetric(vertical: 8),&#10;      child: Padding(&#10;        padding: const EdgeInsets.all(12.0),&#10;        child: Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Row(&#10;              children: [&#10;                Tooltip(&#10;                  message: execution.description ?? '',&#10;                  child: Text(&#10;                    name,&#10;                    style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),&#10;                  ),&#10;                ),&#10;                const SizedBox(width: 16),&#10;                ElevatedButton(&#10;                  onPressed: () =&gt; _confirmAndRunExecution(context),&#10;                  child: const Text('Run'),&#10;                ),&#10;              ],&#10;            ),&#10;            const SizedBox(height: 8),&#10;            if (execution.variable.isNotEmpty)&#10;              Wrap(&#10;                spacing: 8,&#10;                children: execution.variable.map((v) {&#10;                  return SizedBox(&#10;                    width: 120,&#10;                    child: TextField(&#10;                      controller: controllers[v],&#10;                      decoration: InputDecoration(&#10;                        labelText: v,&#10;                      ),&#10;                    ),&#10;                  );&#10;                }).toList(),&#10;              ),&#10;            const SizedBox(height: 8),&#10;            Text(&#10;              _buildCommand({for (final v in execution.variable) v: controllers[v]?.text ?? ''}),&#10;              style: const TextStyle(fontFamily: 'monospace'),&#10;            ),&#10;          ],&#10;        ),&#10;      ),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/execution_list.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/execution_list.dart" />
              <option name="originalContent" value="import 'dart:convert';&#10;import 'dart:io';&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/schema/config.dart';&#10;import 'package:launsh/schema/execution.dart';&#10;import 'package:launsh/execution.dart';&#10;&#10;class ExecutionList extends StatefulWidget {&#10;  final String? configFilePath;&#10;  const ExecutionList({super.key, required this.configFilePath});&#10;&#10;  @override&#10;  State&lt;ExecutionList&gt; createState() =&gt; _ExecutionListState();&#10;}&#10;&#10;class _ExecutionListState extends State&lt;ExecutionList&gt; {&#10;  Config? _config;&#10;  final Map&lt;String, Map&lt;String, TextEditingController&gt;&gt; _variableControllers = {};&#10;&#10;  @override&#10;  void didUpdateWidget(covariant ExecutionList oldWidget) {&#10;    super.didUpdateWidget(oldWidget);&#10;    if (widget.configFilePath != oldWidget.configFilePath) {&#10;      _loadConfig(widget.configFilePath);&#10;    }&#10;  }&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    _loadConfig(widget.configFilePath);&#10;  }&#10;&#10;  Future&lt;void&gt; _loadConfig(String? path) async {&#10;    if (path == null) {&#10;      setState(() {&#10;        _config = null;&#10;        _variableControllers.clear();&#10;      });&#10;      return;&#10;    }&#10;    try {&#10;      final file = File(path);&#10;      final jsonStr = await file.readAsString();&#10;      final jsonMap = json.decode(jsonStr) as Map&lt;String, dynamic&gt;;&#10;      final config = Config.fromJson(jsonMap);&#10;      setState(() {&#10;        _config = config;&#10;        _variableControllers.clear();&#10;        for (final entry in config.executions.entries) {&#10;          _variableControllers[entry.key] = {&#10;            for (final v in entry.value.variable)&#10;              v: TextEditingController(),&#10;          };&#10;        }&#10;      });&#10;    } catch (e) {&#10;      setState(() {&#10;        _config = null;&#10;        _variableControllers.clear();&#10;      });&#10;    }&#10;  }&#10;&#10;  Future&lt;void&gt; _confirmAndRunExecution(String name, Execution execution) async {&#10;    final variableValues = &lt;String, String&gt;{};&#10;    final controllers = _variableControllers[name] ?? {};&#10;    for (final v in execution.variable) {&#10;      variableValues[v] = controllers[v]?.text ?? '';&#10;    }&#10;    final command = _buildCommand(execution, variableValues);&#10;    final confirmed = await showDialog&lt;bool&gt;(&#10;      context: context,&#10;      builder: (context) =&gt; AlertDialog(&#10;        title: const Text('Confirm Execution'),&#10;        content: Text('Run the following command?\n\n$command'),&#10;        actions: [&#10;          TextButton(&#10;            onPressed: () =&gt; Navigator.of(context).pop(false),&#10;            child: const Text('Cancel'),&#10;          ),&#10;          ElevatedButton(&#10;            onPressed: () =&gt; Navigator.of(context).pop(true),&#10;            child: const Text('Run'),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;    if (confirmed == true) {&#10;      _runExecution(name, execution, variableValues);&#10;    }&#10;  }&#10;&#10;  String _buildCommand(Execution execution, Map&lt;String, String&gt; variableValues) {&#10;    String cmd = execution.program;&#10;    if (execution.args.isNotEmpty) {&#10;      cmd += ' ' + execution.args.join(' ');&#10;    }&#10;    if (variableValues.isNotEmpty) {&#10;      cmd += ' ' + variableValues.entries.map((e) =&gt; '${e.key}=${e.value}').join(' ');&#10;    }&#10;    return cmd;&#10;  }&#10;&#10;  Future&lt;void&gt; _runExecution(String name, Execution execution, Map&lt;String, String&gt; variableValues) async {&#10;    // You may want to send logs to ExecutionLog via a callback or a global state&#10;    try {&#10;      final process = await Process.start(&#10;        execution.program,&#10;        execution.args + variableValues.values.toList(),&#10;        workingDirectory: execution.workingDir,&#10;        environment: execution.environment,&#10;        runInShell: true,&#10;      );&#10;      process.stdout.transform(utf8.decoder).listen((data) {&#10;        // Send log to ExecutionLog&#10;      });&#10;      process.stderr.transform(utf8.decoder).listen((data) {&#10;        // Send log to ExecutionLog&#10;      });&#10;      final exitCode = await process.exitCode;&#10;      // Send log to ExecutionLog&#10;    } catch (e) {&#10;      // Send log to ExecutionLog&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    if (_config == null) {&#10;      return const Center(child: Text('No config loaded'));&#10;    }&#10;    return ListView(&#10;      children: _config!.executions.entries.map((entry) {&#10;        final name = entry.key;&#10;        final execution = entry.value;&#10;        final controllers = _variableControllers[name] ?? {};&#10;        return ExecutionEntry(&#10;          name: name,&#10;          execution: execution,&#10;          controllers: controllers,&#10;          onRun: () =&gt; _confirmAndRunExecution(name, execution),&#10;        );&#10;      }).toList(),&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'dart:convert';&#10;import 'dart:io';&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/schema/config.dart';&#10;import 'package:launsh/schema/execution.dart';&#10;import 'package:launsh/execution.dart';&#10;&#10;class ExecutionList extends StatefulWidget {&#10;  final String? configFilePath;&#10;  const ExecutionList({super.key, required this.configFilePath});&#10;&#10;  @override&#10;  State&lt;ExecutionList&gt; createState() =&gt; _ExecutionListState();&#10;}&#10;&#10;class _ExecutionListState extends State&lt;ExecutionList&gt; {&#10;  Config? _config;&#10;  final Map&lt;String, Map&lt;String, TextEditingController&gt;&gt; _variableControllers = {};&#10;&#10;  @override&#10;  void didUpdateWidget(covariant ExecutionList oldWidget) {&#10;    super.didUpdateWidget(oldWidget);&#10;    if (widget.configFilePath != oldWidget.configFilePath) {&#10;      _loadConfig(widget.configFilePath);&#10;    }&#10;  }&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    _loadConfig(widget.configFilePath);&#10;  }&#10;&#10;  Future&lt;void&gt; _loadConfig(String? path) async {&#10;    if (path == null) {&#10;      setState(() {&#10;        _config = null;&#10;        _variableControllers.clear();&#10;      });&#10;      return;&#10;    }&#10;    try {&#10;      final file = File(path);&#10;      final jsonStr = await file.readAsString();&#10;      final jsonMap = json.decode(jsonStr) as Map&lt;String, dynamic&gt;;&#10;      final config = Config.fromJson(jsonMap);&#10;      setState(() {&#10;        _config = config;&#10;        _variableControllers.clear();&#10;        for (final entry in config.executions.entries) {&#10;          _variableControllers[entry.key] = {&#10;            for (final v in entry.value.variable)&#10;              v: TextEditingController(),&#10;          };&#10;        }&#10;      });&#10;    } catch (e) {&#10;      setState(() {&#10;        _config = null;&#10;        _variableControllers.clear();&#10;      });&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    if (_config == null) {&#10;      return const Center(child: Text('No config loaded'));&#10;    }&#10;    return ListView(&#10;      children: _config!.executions.entries.map((entry) {&#10;        final name = entry.key;&#10;        final execution = entry.value;&#10;        final controllers = _variableControllers[name] ?? {};&#10;        return ExecutionEntry(&#10;          name: name,&#10;          execution: execution,&#10;          controllers: controllers,&#10;        );&#10;      }).toList(),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/execution_log.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/execution_log.dart" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;&#10;class ExecutionLog extends StatefulWidget {&#10;  const ExecutionLog({super.key});&#10;&#10;  @override&#10;  State&lt;ExecutionLog&gt; createState() =&gt; _ExecutionLogState();&#10;}&#10;&#10;class _ExecutionLogState extends State&lt;ExecutionLog&gt; {&#10;  final List&lt;String&gt; _logs = [];&#10;&#10;  void addLog(String log) {&#10;    setState(() {&#10;      _logs.add(log);&#10;    });&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Container(&#10;      decoration: BoxDecoration(&#10;        border: Border.all(color: Colors.grey),&#10;        borderRadius: BorderRadius.circular(8),&#10;      ),&#10;      padding: const EdgeInsets.all(8),&#10;      child: Column(&#10;        crossAxisAlignment: CrossAxisAlignment.start,&#10;        children: [&#10;          const Text('Execution Log', style: TextStyle(fontWeight: FontWeight.bold)),&#10;          const Divider(),&#10;          Expanded(&#10;            child: ListView(&#10;              children: _logs.map((log) =&gt; Text(log)).toList(),&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/main.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/main.dart" />
              <option name="originalContent" value="import 'dart:convert';&#10;import 'dart:io';&#10;&#10;import 'package:flutter/material.dart';&#10;import 'package:file_picker/file_picker.dart';&#10;import 'package:launsh/schema/config.dart';&#10;import 'package:launsh/schema/execution.dart';&#10;import 'package:launsh/execution_list.dart';&#10;import 'package:launsh/execution_log.dart';&#10;&#10;void main() {&#10;  runApp(const LaunshApp());&#10;}&#10;&#10;class LaunshApp extends StatelessWidget {&#10;  const LaunshApp({super.key});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return MaterialApp(&#10;      title: 'Launsh',&#10;      theme: ThemeData(&#10;        primarySwatch: Colors.blue,&#10;        visualDensity: VisualDensity.adaptivePlatformDensity,&#10;      ),&#10;      home: const ConfigLauncherPage(),&#10;    );&#10;  }&#10;}&#10;&#10;class ConfigLauncherPage extends StatefulWidget {&#10;  const ConfigLauncherPage({super.key});&#10;&#10;  @override&#10;  State&lt;ConfigLauncherPage&gt; createState() =&gt; _ConfigLauncherPageState();&#10;}&#10;&#10;class _ConfigLauncherPageState extends State&lt;ConfigLauncherPage&gt; {&#10;  String? _configFilePath;&#10;  Config? _config;&#10;  final Map&lt;String, Map&lt;String, TextEditingController&gt;&gt; _variableControllers = {};&#10;  final List&lt;String&gt; _logs = [];&#10;&#10;  Future&lt;void&gt; _pickConfigFile() async {&#10;    final result = await FilePicker.platform.pickFiles(&#10;      type: FileType.custom,&#10;      allowedExtensions: ['json'],&#10;    );&#10;    if (result != null &amp;&amp; result.files.single.path != null) {&#10;      final path = result.files.single.path!;&#10;      setState(() {&#10;        _configFilePath = path;&#10;      });&#10;      await _loadConfig(path);&#10;    }&#10;  }&#10;&#10;  Future&lt;void&gt; _loadConfig(String path) async {&#10;    try {&#10;      final file = File(path);&#10;      final jsonStr = await file.readAsString();&#10;      final jsonMap = json.decode(jsonStr) as Map&lt;String, dynamic&gt;;&#10;      final config = Config.fromJson(jsonMap);&#10;      setState(() {&#10;        _config = config;&#10;        _variableControllers.clear();&#10;        for (final entry in config.executions.entries) {&#10;          _variableControllers[entry.key] = {&#10;            for (final v in entry.value.variable)&#10;              v: TextEditingController(),&#10;          };&#10;        }&#10;      });&#10;    } catch (e) {&#10;      setState(() {&#10;        _config = null;&#10;      });&#10;      _addLog('Failed to load config: $e');&#10;    }&#10;  }&#10;&#10;  void _addLog(String log) {&#10;    setState(() {&#10;      _logs.add(log);&#10;    });&#10;  }&#10;&#10;  Future&lt;void&gt; _confirmAndRunExecution(String name, Execution execution) async {&#10;    final variableValues = &lt;String, String&gt;{};&#10;    final controllers = _variableControllers[name] ?? {};&#10;    for (final v in execution.variable) {&#10;      variableValues[v] = controllers[v]?.text ?? '';&#10;    }&#10;    final command = _buildCommand(execution, variableValues);&#10;    final confirmed = await showDialog&lt;bool&gt;(&#10;      context: context,&#10;      builder: (context) =&gt; AlertDialog(&#10;        title: const Text('Confirm Execution'),&#10;        content: Text('Run the following command?\n\n$command'),&#10;        actions: [&#10;          TextButton(&#10;            onPressed: () =&gt; Navigator.of(context).pop(false),&#10;            child: const Text('Cancel'),&#10;          ),&#10;          ElevatedButton(&#10;            onPressed: () =&gt; Navigator.of(context).pop(true),&#10;            child: const Text('Run'),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;    if (confirmed == true) {&#10;      _runExecution(name, execution, variableValues);&#10;    }&#10;  }&#10;&#10;  String _buildCommand(Execution execution, Map&lt;String, String&gt; variableValues) {&#10;    String cmd = execution.program;&#10;    if (execution.args.isNotEmpty) {&#10;      cmd += ' ' + execution.args.join(' ');&#10;    }&#10;    if (variableValues.isNotEmpty) {&#10;      cmd += ' ' + variableValues.entries.map((e) =&gt; '${e.key}=${e.value}').join(' ');&#10;    }&#10;    return cmd;&#10;  }&#10;&#10;  Future&lt;void&gt; _runExecution(String name, Execution execution, Map&lt;String, String&gt; variableValues) async {&#10;    _addLog('Running &quot;$name&quot;...');&#10;    try {&#10;      final process = await Process.start(&#10;        execution.program,&#10;        execution.args + variableValues.values.toList(),&#10;        workingDirectory: execution.workingDir,&#10;        environment: execution.environment,&#10;        runInShell: true,&#10;      );&#10;      process.stdout.transform(utf8.decoder).listen((data) {&#10;        _addLog('[stdout] $data');&#10;      });&#10;      process.stderr.transform(utf8.decoder).listen((data) {&#10;        _addLog('[stderr] $data');&#10;      });&#10;      final exitCode = await process.exitCode;&#10;      _addLog('&quot;$name&quot; finished with exit code $exitCode');&#10;    } catch (e) {&#10;      _addLog('Failed to run &quot;$name&quot;: $e');&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(title: const Text('Launsh Config Launcher')),&#10;      body: Padding(&#10;        padding: const EdgeInsets.all(16.0),&#10;        child: Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Row(&#10;              children: [&#10;                ElevatedButton(&#10;                  onPressed: _pickConfigFile,&#10;                  child: const Text('Pick Config File'),&#10;                ),&#10;                const SizedBox(width: 16),&#10;                Expanded(&#10;                  child: Text(&#10;                    _configFilePath ?? 'No config file selected',&#10;                    style: const TextStyle(fontWeight: FontWeight.bold),&#10;                  ),&#10;                ),&#10;              ],&#10;            ),&#10;            const SizedBox(height: 24),&#10;            if (_config != null)&#10;              Expanded(&#10;                child: Row(&#10;                  children: [&#10;                    Expanded(&#10;                      flex: 2,&#10;                      child: ExecutionList(&#10;                        config: _config!,&#10;                        variableControllers: _variableControllers,&#10;                        onRun: (name, execution) =&gt; _confirmAndRunExecution(name, execution),&#10;                      ),&#10;                    ),&#10;                    const SizedBox(width: 16),&#10;                    Expanded(&#10;                      flex: 1,&#10;                      child: ExecutionLog(logs: _logs),&#10;                    ),&#10;                  ],&#10;                ),&#10;              ),&#10;          ],&#10;        ),&#10;      ),&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'dart:convert';&#10;import 'dart:io';&#10;&#10;import 'package:flutter/material.dart';&#10;import 'package:file_picker/file_picker.dart';&#10;import 'package:launsh/schema/config.dart';&#10;import 'package:launsh/schema/execution.dart';&#10;import 'package:launsh/execution_list.dart';&#10;import 'package:launsh/execution_log.dart';&#10;&#10;void main() {&#10;  runApp(const LaunshApp());&#10;}&#10;&#10;class LaunshApp extends StatelessWidget {&#10;  const LaunshApp({super.key});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return MaterialApp(&#10;      title: 'Launsh',&#10;      theme: ThemeData(&#10;        primarySwatch: Colors.blue,&#10;        visualDensity: VisualDensity.adaptivePlatformDensity,&#10;      ),&#10;      home: const ConfigLauncherPage(),&#10;    );&#10;  }&#10;}&#10;&#10;class ConfigLauncherPage extends StatefulWidget {&#10;  const ConfigLauncherPage({super.key});&#10;&#10;  @override&#10;  State&lt;ConfigLauncherPage&gt; createState() =&gt; _ConfigLauncherPageState();&#10;}&#10;&#10;class _ConfigLauncherPageState extends State&lt;ConfigLauncherPage&gt; {&#10;  String? _configFilePath;&#10;&#10;  Future&lt;void&gt; _pickConfigFile() async {&#10;    final result = await FilePicker.platform.pickFiles(&#10;      type: FileType.custom,&#10;      allowedExtensions: ['json'],&#10;    );&#10;    if (result != null &amp;&amp; result.files.single.path != null) {&#10;      final path = result.files.single.path!;&#10;      setState(() {&#10;        _configFilePath = path;&#10;      });&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(title: const Text('Launsh Config Launcher')),&#10;      body: Padding(&#10;        padding: const EdgeInsets.all(16.0),&#10;        child: Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Row(&#10;              children: [&#10;                ElevatedButton(&#10;                  onPressed: _pickConfigFile,&#10;                  child: const Text('Pick Config File'),&#10;                ),&#10;                const SizedBox(width: 16),&#10;                Expanded(&#10;                  child: Text(&#10;                    _configFilePath ?? 'No config file selected',&#10;                    style: const TextStyle(fontWeight: FontWeight.bold),&#10;                  ),&#10;                ),&#10;              ],&#10;            ),&#10;            const SizedBox(height: 24),&#10;            Expanded(&#10;              child: Row(&#10;                children: [&#10;                  Expanded(&#10;                    flex: 2,&#10;                    child: ExecutionList(&#10;                      configFilePath: _configFilePath,&#10;                    ),&#10;                  ),&#10;                  const SizedBox(width: 16),&#10;                  Expanded(&#10;                    flex: 1,&#10;                    child: ExecutionLog(),&#10;                  ),&#10;                ],&#10;              ),&#10;            ),&#10;          ],&#10;        ),&#10;      ),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/macos/Runner/Info.plist">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/macos/Runner/Info.plist" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&#10;&lt;plist version=&quot;1.0&quot;&gt;&#10;&lt;dict&gt;&#10;&#9;&lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;&#10;&#9;&lt;string&gt;$(DEVELOPMENT_LANGUAGE)&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleExecutable&lt;/key&gt;&#10;&#9;&lt;string&gt;$(EXECUTABLE_NAME)&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleIconFile&lt;/key&gt;&#10;&#9;&lt;string&gt;&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleIdentifier&lt;/key&gt;&#10;&#9;&lt;string&gt;$(PRODUCT_BUNDLE_IDENTIFIER)&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;&#10;&#9;&lt;string&gt;6.0&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleName&lt;/key&gt;&#10;&#9;&lt;string&gt;$(PRODUCT_NAME)&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundlePackageType&lt;/key&gt;&#10;&#9;&lt;string&gt;APPL&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleShortVersionString&lt;/key&gt;&#10;&#9;&lt;string&gt;$(FLUTTER_BUILD_NAME)&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleVersion&lt;/key&gt;&#10;&#9;&lt;string&gt;$(FLUTTER_BUILD_NUMBER)&lt;/string&gt;&#10;&#9;&lt;key&gt;LSMinimumSystemVersion&lt;/key&gt;&#10;&#9;&lt;string&gt;$(MACOSX_DEPLOYMENT_TARGET)&lt;/string&gt;&#10;&#9;&lt;key&gt;NSHumanReadableCopyright&lt;/key&gt;&#10;&#9;&lt;string&gt;$(PRODUCT_COPYRIGHT)&lt;/string&gt;&#10;&#9;&lt;key&gt;NSMainNibFile&lt;/key&gt;&#10;&#9;&lt;string&gt;MainMenu&lt;/string&gt;&#10;&#9;&lt;key&gt;NSPrincipalClass&lt;/key&gt;&#10;&#9;&lt;string&gt;NSApplication&lt;/string&gt;&#10;&lt;/dict&gt;&#10;&lt;/plist&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&#10;&lt;plist version=&quot;1.0&quot;&gt;&#10;&lt;dict&gt;&#10;&#9;&lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;&#10;&#9;&lt;string&gt;$(DEVELOPMENT_LANGUAGE)&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleExecutable&lt;/key&gt;&#10;&#9;&lt;string&gt;$(EXECUTABLE_NAME)&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleIconFile&lt;/key&gt;&#10;&#9;&lt;string&gt;&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleIdentifier&lt;/key&gt;&#10;&#9;&lt;string&gt;$(PRODUCT_BUNDLE_IDENTIFIER)&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;&#10;&#9;&lt;string&gt;6.0&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleName&lt;/key&gt;&#10;&#9;&lt;string&gt;$(PRODUCT_NAME)&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundlePackageType&lt;/key&gt;&#10;&#9;&lt;string&gt;APPL&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleShortVersionString&lt;/key&gt;&#10;&#9;&lt;string&gt;$(FLUTTER_BUILD_NAME)&lt;/string&gt;&#10;&#9;&lt;key&gt;CFBundleVersion&lt;/key&gt;&#10;&#9;&lt;string&gt;$(FLUTTER_BUILD_NUMBER)&lt;/string&gt;&#10;&#9;&lt;key&gt;LSMinimumSystemVersion&lt;/key&gt;&#10;&#9;&lt;string&gt;$(MACOSX_DEPLOYMENT_TARGET)&lt;/string&gt;&#10;&#9;&lt;key&gt;NSHumanReadableCopyright&lt;/key&gt;&#10;&#9;&lt;string&gt;$(PRODUCT_COPYRIGHT)&lt;/string&gt;&#10;&#9;&lt;key&gt;NSMainNibFile&lt;/key&gt;&#10;&#9;&lt;string&gt;MainMenu&lt;/string&gt;&#10;&#9;&lt;key&gt;NSPrincipalClass&lt;/key&gt;&#10;&#9;&lt;string&gt;NSApplication&lt;/string&gt;&#10;&#9;&lt;key&gt;com.apple.security.files.user-selected.read-only&lt;/key&gt;&#10;&#9;&lt;true/&gt;&#10;&#9;&lt;key&gt;com.apple.security.files.user-selected.read-write&lt;/key&gt;&#10;&#9;&lt;true/&gt;&#10;&lt;/dict&gt;&#10;&lt;/plist&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>