<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/lib/component/execution_list.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/component/execution_list.dart" />
              <option name="originalContent" value="import 'dart:convert';&#10;import 'dart:io';&#10;&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/component/execution_entry.dart';&#10;import 'package:launsh/schema/config.dart';&#10;import 'package:path/path.dart' as path;&#10;&#10;class ExecutionList extends StatefulWidget {&#10;  final String? workingDir;&#10;  final LogCallback onLog;&#10;&#10;  const ExecutionList({&#10;    super.key,&#10;    required this.workingDir,&#10;    required this.onLog,&#10;  });&#10;&#10;  @override&#10;  State&lt;ExecutionList&gt; createState() =&gt; _ExecutionListState();&#10;}&#10;&#10;class _ExecutionListState extends State&lt;ExecutionList&gt; {&#10;  Config? _config;&#10;&#10;  @override&#10;  void didUpdateWidget(covariant ExecutionList oldWidget) {&#10;    super.didUpdateWidget(oldWidget);&#10;    if (widget.workingDir != null) {&#10;      _loadConfig(path.join(widget.workingDir!, 'launsh.json'));&#10;    }&#10;  }&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    if (widget.workingDir != null) {&#10;      _loadConfig(path.join(widget.workingDir!, 'launsh.json'));&#10;    }&#10;  }&#10;&#10;  Future&lt;void&gt; _loadConfig(String? path) async {&#10;    if (path == null) {&#10;      setState(() {&#10;        _config = null;&#10;      });&#10;      return;&#10;    }&#10;    try {&#10;      final file = File(path);&#10;      final jsonStr = await file.readAsString();&#10;      final jsonMap = json.decode(jsonStr) as Map&lt;String, dynamic&gt;;&#10;      final config = Config.fromJson(jsonMap);&#10;      config.validate();&#10;&#10;      setState(() {&#10;        _config = config;&#10;      });&#10;    } catch (e) {&#10;      widget.onLog('Error loading config: $e');&#10;      setState(() {&#10;        _config = null;&#10;      });&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    if (widget.workingDir == null) {&#10;      return const Center(child: Text('Please select a working directory.'));&#10;    }&#10;    if (_config == null) {&#10;      return const Center(child: Text('Loading or failed to load config...'));&#10;    }&#10;    return ListView(&#10;      padding: const EdgeInsets.all(8),&#10;      children: _config!.executions.entries.map((entry) {&#10;        final name = entry.key;&#10;        final execution = entry.value;&#10;        return ExecutionEntry(&#10;          // Using a key is good practice for lists of stateful widgets&#10;          key: ValueKey(name),&#10;          workingDir: widget.workingDir!,&#10;          name: name,&#10;          execution: execution,&#10;          onLog: widget.onLog,&#10;        );&#10;      }).toList(),&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'dart:convert';&#10;import 'dart:io';&#10;&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/component/execution_entry.dart';&#10;import 'package:launsh/schema/config.dart';&#10;import 'package:path/path.dart' as path;&#10;&#10;class ExecutionList extends StatefulWidget {&#10;  final String? workingDir;&#10;  final LogCallback onLog;&#10;&#10;  const ExecutionList({&#10;    super.key,&#10;    required this.workingDir,&#10;    required this.onLog,&#10;  });&#10;&#10;  @override&#10;  State&lt;ExecutionList&gt; createState() =&gt; _ExecutionListState();&#10;}&#10;&#10;class _ExecutionListState extends State&lt;ExecutionList&gt; {&#10;  Config? _config;&#10;&#10;  @override&#10;  void didUpdateWidget(covariant ExecutionList oldWidget) {&#10;    super.didUpdateWidget(oldWidget);&#10;    if (widget.workingDir != null) {&#10;      _loadConfig(path.join(widget.workingDir!, 'launsh.json'));&#10;    }&#10;  }&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    if (widget.workingDir != null) {&#10;      _loadConfig(path.join(widget.workingDir!, 'launsh.json'));&#10;    }&#10;  }&#10;&#10;  Future&lt;void&gt; _loadConfig(String? path) async {&#10;    if (path == null) {&#10;      setState(() {&#10;        _config = null;&#10;      });&#10;      return;&#10;    }&#10;    try {&#10;      final file = File(path);&#10;      final jsonStr = await file.readAsString();&#10;      final jsonMap = json.decode(jsonStr) as Map&lt;String, dynamic&gt;;&#10;      final config = Config.fromJson(jsonMap);&#10;      config.validate();&#10;&#10;      setState(() {&#10;        _config = config;&#10;      });&#10;    } catch (e) {&#10;      widget.onLog('Error loading config: $e');&#10;      setState(() {&#10;        _config = null;&#10;      });&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    if (widget.workingDir == null) {&#10;      return const Center(child: Text('Please select a working directory.'));&#10;    }&#10;    if (_config == null) {&#10;      return const Center(child: Text('Loading or failed to load config...'));&#10;    }&#10;    return Column(&#10;      crossAxisAlignment: CrossAxisAlignment.start,&#10;      children: [&#10;        const Padding(&#10;          padding: EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),&#10;          child: Text(&#10;            'Jobs',&#10;            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),&#10;          ),&#10;        ),&#10;        Expanded(&#10;          child: ListView(&#10;            padding: const EdgeInsets.all(8),&#10;            children: _config!.executions.entries.map((entry) {&#10;              final name = entry.key;&#10;              final execution = entry.value;&#10;              return ExecutionEntry(&#10;                // Using a key is good practice for lists of stateful widgets&#10;                key: ValueKey(name),&#10;                workingDir: widget.workingDir!,&#10;                name: name,&#10;                execution: execution,&#10;                onLog: widget.onLog,&#10;              );&#10;            }).toList(),&#10;          ),&#10;        ),&#10;      ],&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/component/execution_log.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/component/execution_log.dart" />
              <option name="originalContent" value="// lib/component/execution_log.dart&#10;&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/component/execution_log_controller.dart';&#10;&#10;class ExecutionLog extends StatelessWidget {&#10;  final ExecutionLogController controller;&#10;&#10;  const ExecutionLog({super.key, required this.controller});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return AnimatedBuilder(&#10;      animation: controller,&#10;      builder: (context, _) {&#10;        return Expanded(&#10;          child: Column(&#10;            crossAxisAlignment: CrossAxisAlignment.start,&#10;            children: [&#10;              const Text(&#10;                'Execution Log',&#10;                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),&#10;              ),&#10;              const SizedBox(height: 8),&#10;              Expanded(&#10;                child: Container(&#10;                  width: double.infinity,&#10;                  padding: const EdgeInsets.all(8.0),&#10;                  decoration: BoxDecoration(&#10;                    border: Border.all(color: Colors.grey.shade400),&#10;                    borderRadius: BorderRadius.circular(4.0),&#10;                    color: Colors.grey.shade100,&#10;                  ),&#10;                  child: SingleChildScrollView(&#10;                    reverse: true,&#10;                    child: Text(controller.log),&#10;                  ),&#10;                ),&#10;              ),&#10;            ],&#10;          ),&#10;        );&#10;      },&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="// lib/component/execution_log.dart&#10;&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/component/execution_log_controller.dart';&#10;&#10;class ExecutionLog extends StatelessWidget {&#10;  final ExecutionLogController controller;&#10;&#10;  const ExecutionLog({super.key, required this.controller});&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return AnimatedBuilder(&#10;      animation: controller,&#10;      builder: (context, _) {&#10;        return Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            const Text(&#10;              'Execution Log',&#10;              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),&#10;            ),&#10;            const SizedBox(height: 8),&#10;            Expanded(&#10;              child: Container(&#10;                width: double.infinity,&#10;                padding: const EdgeInsets.all(8.0),&#10;                decoration: BoxDecoration(&#10;                  border: Border.all(color: Colors.grey.shade400),&#10;                  borderRadius: BorderRadius.circular(4.0),&#10;                  color: Colors.grey.shade100,&#10;                ),&#10;                child: SingleChildScrollView(&#10;                  reverse: true,&#10;                  child: Text(controller.log),&#10;                ),&#10;              ),&#10;            ),&#10;          ],&#10;        );&#10;      },&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/component/execution_log_controller.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/component/execution_log_controller.dart" />
              <option name="updatedContent" value="import 'package:flutter/foundation.dart';&#10;&#10;class ExecutionLogController extends ChangeNotifier {&#10;  final StringBuffer _buffer = StringBuffer();&#10;&#10;  String get log =&gt; _buffer.toString();&#10;&#10;  void add(String message) {&#10;    _buffer.writeln('[${DateTime.now().toIso8601String()}] $message');&#10;    notifyListeners();&#10;  }&#10;&#10;  void clear() {&#10;    _buffer.clear();&#10;    notifyListeners();&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/component/launsh_page.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/component/launsh_page.dart" />
              <option name="originalContent" value="import 'dart:io';&#10;&#10;import 'package:file_picker/file_picker.dart';&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/component/app_log.dart';&#10;import 'package:launsh/component/app_log_controller.dart';&#10;import 'package:launsh/component/execution_list.dart';&#10;import 'package:path/path.dart' as path;&#10;import 'package:url_launcher/url_launcher.dart';&#10;&#10;class LaunshPage extends StatefulWidget {&#10;  const LaunshPage({super.key});&#10;&#10;  @override&#10;  State&lt;LaunshPage&gt; createState() =&gt; _LaunshPageState();&#10;}&#10;&#10;class _LaunshPageState extends State&lt;LaunshPage&gt; {&#10;  String? _workingDir;&#10;  final AppLogController _logController = AppLogController();&#10;&#10;  Future&lt;void&gt; _pickWorkingDir() async {&#10;    final workingDir = await FilePicker.platform.getDirectoryPath();&#10;&#10;    if (workingDir != null) {&#10;      final configFile = File(path.join(workingDir, 'launsh.json'));&#10;      if (!configFile.existsSync()) {&#10;        setState(() {&#10;          _workingDir = null;&#10;          _logController.add(&#10;            'Config file &quot;launsh.json&quot; not found in the selected directory: $workingDir',&#10;          );&#10;        });&#10;      } else {&#10;        setState(() {&#10;          _workingDir = workingDir;&#10;          _logController.add('Selected working directory: $workingDir');&#10;        });&#10;      }&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(title: const Text('Launsh GUI')),&#10;      body: Column(&#10;        children: [&#10;          // 上部にフォルダ選択コントロール&#10;          Padding(&#10;            padding: const EdgeInsets.all(16.0),&#10;            child: Row(&#10;              children: [&#10;                ElevatedButton.icon(&#10;                  icon: const Icon(Icons.folder),&#10;                  onPressed: _pickWorkingDir,&#10;                  label: const Text('Select Working Directory'),&#10;                ),&#10;                const SizedBox(width: 16),&#10;                Expanded(&#10;                  child: Text(&#10;                    _workingDir ?? 'No working directory selected',&#10;                    overflow: TextOverflow.ellipsis,&#10;                  ),&#10;                ),&#10;                if (_workingDir != null)&#10;                  ElevatedButton.icon(&#10;                    icon: const Icon(Icons.description),&#10;                    label: const Text('Open Config'),&#10;                    onPressed: () async {&#10;                      final configPath = path.join(_workingDir!, 'launsh.json');&#10;                      final uri = Uri.file(configPath);&#10;                      if (!await launchUrl(uri)) {&#10;                        _logController.add(&#10;                          'Could not open config file: $configPath',&#10;                        );&#10;                      }&#10;                    },&#10;                  ),&#10;                if (_workingDir != null)&#10;                  IconButton(&#10;                    icon: const Icon(Icons.refresh),&#10;                    tooltip: 'Reload working directory',&#10;                    onPressed: () {&#10;                      if (_workingDir != null) {&#10;                        setState(() {&#10;                          _logController.add(&#10;                            'Reloaded working directory: $_workingDir',&#10;                          );&#10;                        });&#10;                      }&#10;                    },&#10;                  ),&#10;              ],&#10;            ),&#10;          ),&#10;          const Divider(),&#10;          // 下部にExecutionListとAppLogを左右に並べる&#10;          Expanded(&#10;            child: Row(&#10;              children: [&#10;                Expanded(&#10;                  flex: 3,&#10;                  child: ExecutionList(&#10;                    workingDir: _workingDir,&#10;                    onLog: _logController.add,&#10;                  ),&#10;                ),&#10;                const VerticalDivider(width: 1),&#10;                Expanded(&#10;                  flex: 2,&#10;                  child: AppLog(controller: _logController),&#10;                ),&#10;              ],&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'dart:io';&#10;&#10;import 'package:file_picker/file_picker.dart';&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/component/app_log.dart';&#10;import 'package:launsh/component/app_log_controller.dart';&#10;import 'package:launsh/component/execution_list.dart';&#10;import 'package:path/path.dart' as path;&#10;import 'package:url_launcher/url_launcher.dart';&#10;&#10;class LaunshPage extends StatefulWidget {&#10;  const LaunshPage({super.key});&#10;&#10;  @override&#10;  State&lt;LaunshPage&gt; createState() =&gt; _LaunshPageState();&#10;}&#10;&#10;class _LaunshPageState extends State&lt;LaunshPage&gt; {&#10;  String? _workingDir;&#10;  final AppLogController _logController = AppLogController();&#10;  double _leftPanelFraction = 0.6; // 左パネルの幅割合&#10;  static const double _minPanelFraction = 0.2;&#10;  static const double _maxPanelFraction = 0.8;&#10;&#10;  Future&lt;void&gt; _pickWorkingDir() async {&#10;    final workingDir = await FilePicker.platform.getDirectoryPath();&#10;&#10;    if (workingDir != null) {&#10;      final configFile = File(path.join(workingDir, 'launsh.json'));&#10;      if (!configFile.existsSync()) {&#10;        setState(() {&#10;          _workingDir = null;&#10;          _logController.add(&#10;            'Config file &quot;launsh.json&quot; not found in the selected directory: $workingDir',&#10;          );&#10;        });&#10;      } else {&#10;        setState(() {&#10;          _workingDir = workingDir;&#10;          _logController.add('Selected working directory: $workingDir');&#10;        });&#10;      }&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Scaffold(&#10;      appBar: AppBar(title: const Text('Launsh GUI')),&#10;      body: Column(&#10;        children: [&#10;          // 上部にフォルダ選択コントロール&#10;          Padding(&#10;            padding: const EdgeInsets.all(16.0),&#10;            child: Row(&#10;              children: [&#10;                ElevatedButton.icon(&#10;                  icon: const Icon(Icons.folder),&#10;                  onPressed: _pickWorkingDir,&#10;                  label: const Text('Select Working Directory'),&#10;                ),&#10;                const SizedBox(width: 16),&#10;                Expanded(&#10;                  child: Text(&#10;                    _workingDir ?? 'No working directory selected',&#10;                    overflow: TextOverflow.ellipsis,&#10;                  ),&#10;                ),&#10;                if (_workingDir != null)&#10;                  ElevatedButton.icon(&#10;                    icon: const Icon(Icons.description),&#10;                    label: const Text('Open Config'),&#10;                    onPressed: () async {&#10;                      final configPath = path.join(_workingDir!, 'launsh.json');&#10;                      final uri = Uri.file(configPath);&#10;                      if (!await launchUrl(uri)) {&#10;                        _logController.add(&#10;                          'Could not open config file: $configPath',&#10;                        );&#10;                      }&#10;                    },&#10;                  ),&#10;                if (_workingDir != null)&#10;                  IconButton(&#10;                    icon: const Icon(Icons.refresh),&#10;                    tooltip: 'Reload working directory',&#10;                    onPressed: () {&#10;                      if (_workingDir != null) {&#10;                        setState(() {&#10;                          _logController.add(&#10;                            'Reloaded working directory: $_workingDir',&#10;                          );&#10;                        });&#10;                      }&#10;                    },&#10;                  ),&#10;              ],&#10;            ),&#10;          ),&#10;          const Divider(),&#10;          // 下部にExecutionListとAppLogを左右に並べる（ドラッグ可能な分割線付き）&#10;          Expanded(&#10;            child: LayoutBuilder(&#10;              builder: (context, constraints) {&#10;                final width = constraints.maxWidth;&#10;                final leftWidth = width * _leftPanelFraction;&#10;                final rightWidth = width * (1 - _leftPanelFraction);&#10;                return Row(&#10;                  children: [&#10;                    SizedBox(&#10;                      width: leftWidth,&#10;                      child: ExecutionList(&#10;                        workingDir: _workingDir,&#10;                        onLog: _logController.add,&#10;                      ),&#10;                    ),&#10;                    // ドラッグ可能な分割線&#10;                    GestureDetector(&#10;                      behavior: HitTestBehavior.translucent,&#10;                      onHorizontalDragUpdate: (details) {&#10;                        setState(() {&#10;                          _leftPanelFraction += details.delta.dx / width;&#10;                          _leftPanelFraction = _leftPanelFraction.clamp(&#10;                              _minPanelFraction, _maxPanelFraction);&#10;                        });&#10;                      },&#10;                      child: MouseRegion(&#10;                        cursor: SystemMouseCursors.resizeColumn,&#10;                        child: Container(&#10;                          width: 8,&#10;                          height: double.infinity,&#10;                          color: Colors.grey[300],&#10;                          child: const Center(&#10;                            child: VerticalDivider(&#10;                              width: 8,&#10;                              thickness: 2,&#10;                              color: Colors.grey,&#10;                            ),&#10;                          ),&#10;                        ),&#10;                      ),&#10;                    ),&#10;                    SizedBox(&#10;                      width: rightWidth - 8, // 分割線の幅を引く&#10;                      child: AppLog(controller: _logController),&#10;                    ),&#10;                  ],&#10;                );&#10;              },&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/execution.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/execution.dart" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import 'dart:convert';&#10;import 'dart:io';&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/schema/execution.dart';&#10;&#10;class ExecutionEntry extends StatelessWidget {&#10;  final String name;&#10;  final Execution execution;&#10;  final Map&lt;String, TextEditingController&gt; controllers;&#10;&#10;  const ExecutionEntry({&#10;    super.key,&#10;    required this.name,&#10;    required this.execution,&#10;    required this.controllers,&#10;  });&#10;&#10;  Future&lt;void&gt; _confirmAndRunExecution(BuildContext context) async {&#10;    final variableValues = &lt;String, String&gt;{};&#10;    for (final v in execution.variable) {&#10;      variableValues[v] = controllers[v]?.text ?? '';&#10;    }&#10;    final command = _buildCommand(variableValues);&#10;    final confirmed = await showDialog&lt;bool&gt;(&#10;      context: context,&#10;      builder: (context) =&gt; AlertDialog(&#10;        title: const Text('Confirm Execution'),&#10;        content: Text('Run the following command?\n\n$command'),&#10;        actions: [&#10;          TextButton(&#10;            onPressed: () =&gt; Navigator.of(context).pop(false),&#10;            child: const Text('Cancel'),&#10;          ),&#10;          ElevatedButton(&#10;            onPressed: () =&gt; Navigator.of(context).pop(true),&#10;            child: const Text('Run'),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;    if (confirmed == true) {&#10;      await _runExecution(variableValues);&#10;    }&#10;  }&#10;&#10;  String _buildCommand(Map&lt;String, String&gt; variableValues) {&#10;    String cmd = execution.program;&#10;    if (execution.args.isNotEmpty) {&#10;      cmd += ' ' + execution.args.join(' ');&#10;    }&#10;    if (variableValues.isNotEmpty) {&#10;      cmd += ' ' + variableValues.entries.map((e) =&gt; '${e.key}=${e.value}').join(' ');&#10;    }&#10;    return cmd;&#10;  }&#10;&#10;  Future&lt;void&gt; _runExecution(Map&lt;String, String&gt; variableValues) async {&#10;    // You may want to send logs to ExecutionLog via a callback or a global state&#10;    try {&#10;      final process = await Process.start(&#10;        execution.program,&#10;        execution.args + variableValues.values.toList(),&#10;        workingDirectory: execution.workingDir,&#10;        environment: execution.environment,&#10;        runInShell: true,&#10;      );&#10;      process.stdout.transform(utf8.decoder).listen((data) {&#10;        // Send log to ExecutionLog&#10;      });&#10;      process.stderr.transform(utf8.decoder).listen((data) {&#10;        // Send log to ExecutionLog&#10;      });&#10;      final exitCode = await process.exitCode;&#10;      // Send log to ExecutionLog&#10;    } catch (e) {&#10;      // Send log to ExecutionLog&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Card(&#10;      margin: const EdgeInsets.symmetric(vertical: 8),&#10;      child: Padding(&#10;        padding: const EdgeInsets.all(12.0),&#10;        child: Column(&#10;          crossAxisAlignment: CrossAxisAlignment.start,&#10;          children: [&#10;            Row(&#10;              children: [&#10;                Tooltip(&#10;                  message: execution.description ?? '',&#10;                  child: Text(&#10;                    name,&#10;                    style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),&#10;                  ),&#10;                ),&#10;                const SizedBox(width: 16),&#10;                ElevatedButton(&#10;                  onPressed: () =&gt; _confirmAndRunExecution(context),&#10;                  child: const Text('Run'),&#10;                ),&#10;              ],&#10;            ),&#10;            const SizedBox(height: 8),&#10;            if (execution.variable.isNotEmpty)&#10;              Wrap(&#10;                spacing: 8,&#10;                children: execution.variable.map((v) {&#10;                  return SizedBox(&#10;                    width: 120,&#10;                    child: TextField(&#10;                      controller: controllers[v],&#10;                      decoration: InputDecoration(&#10;                        labelText: v,&#10;                      ),&#10;                    ),&#10;                  );&#10;                }).toList(),&#10;              ),&#10;            const SizedBox(height: 8),&#10;            Text(&#10;              _buildCommand({for (final v in execution.variable) v: controllers[v]?.text ?? ''}),&#10;              style: const TextStyle(fontFamily: 'monospace'),&#10;            ),&#10;          ],&#10;        ),&#10;      ),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/execution_list.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/execution_list.dart" />
              <option name="originalContent" value="import 'dart:convert';&#10;import 'dart:io';&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/schema/config.dart';&#10;import 'package:launsh/schema/execution.dart';&#10;import 'package:launsh/execution.dart';&#10;&#10;class ExecutionList extends StatefulWidget {&#10;  final String? configFilePath;&#10;  const ExecutionList({super.key, required this.configFilePath});&#10;&#10;  @override&#10;  State&lt;ExecutionList&gt; createState() =&gt; _ExecutionListState();&#10;}&#10;&#10;class _ExecutionListState extends State&lt;ExecutionList&gt; {&#10;  Config? _config;&#10;  final Map&lt;String, Map&lt;String, TextEditingController&gt;&gt; _variableControllers = {};&#10;&#10;  @override&#10;  void didUpdateWidget(covariant ExecutionList oldWidget) {&#10;    super.didUpdateWidget(oldWidget);&#10;    if (widget.configFilePath != oldWidget.configFilePath) {&#10;      _loadConfig(widget.configFilePath);&#10;    }&#10;  }&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    _loadConfig(widget.configFilePath);&#10;  }&#10;&#10;  Future&lt;void&gt; _loadConfig(String? path) async {&#10;    if (path == null) {&#10;      setState(() {&#10;        _config = null;&#10;        _variableControllers.clear();&#10;      });&#10;      return;&#10;    }&#10;    try {&#10;      final file = File(path);&#10;      final jsonStr = await file.readAsString();&#10;      final jsonMap = json.decode(jsonStr) as Map&lt;String, dynamic&gt;;&#10;      final config = Config.fromJson(jsonMap);&#10;      setState(() {&#10;        _config = config;&#10;        _variableControllers.clear();&#10;        for (final entry in config.executions.entries) {&#10;          _variableControllers[entry.key] = {&#10;            for (final v in entry.value.variable)&#10;              v: TextEditingController(),&#10;          };&#10;        }&#10;      });&#10;    } catch (e) {&#10;      setState(() {&#10;        _config = null;&#10;        _variableControllers.clear();&#10;      });&#10;    }&#10;  }&#10;&#10;  Future&lt;void&gt; _confirmAndRunExecution(String name, Execution execution) async {&#10;    final variableValues = &lt;String, String&gt;{};&#10;    final controllers = _variableControllers[name] ?? {};&#10;    for (final v in execution.variable) {&#10;      variableValues[v] = controllers[v]?.text ?? '';&#10;    }&#10;    final command = _buildCommand(execution, variableValues);&#10;    final confirmed = await showDialog&lt;bool&gt;(&#10;      context: context,&#10;      builder: (context) =&gt; AlertDialog(&#10;        title: const Text('Confirm Execution'),&#10;        content: Text('Run the following command?\n\n$command'),&#10;        actions: [&#10;          TextButton(&#10;            onPressed: () =&gt; Navigator.of(context).pop(false),&#10;            child: const Text('Cancel'),&#10;          ),&#10;          ElevatedButton(&#10;            onPressed: () =&gt; Navigator.of(context).pop(true),&#10;            child: const Text('Run'),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;    if (confirmed == true) {&#10;      _runExecution(name, execution, variableValues);&#10;    }&#10;  }&#10;&#10;  String _buildCommand(Execution execution, Map&lt;String, String&gt; variableValues) {&#10;    String cmd = execution.program;&#10;    if (execution.args.isNotEmpty) {&#10;      cmd += ' ' + execution.args.join(' ');&#10;    }&#10;    if (variableValues.isNotEmpty) {&#10;      cmd += ' ' + variableValues.entries.map((e) =&gt; '${e.key}=${e.value}').join(' ');&#10;    }&#10;    return cmd;&#10;  }&#10;&#10;  Future&lt;void&gt; _runExecution(String name, Execution execution, Map&lt;String, String&gt; variableValues) async {&#10;    // You may want to send logs to ExecutionLog via a callback or a global state&#10;    try {&#10;      final process = await Process.start(&#10;        execution.program,&#10;        execution.args + variableValues.values.toList(),&#10;        workingDirectory: execution.workingDir,&#10;        environment: execution.environment,&#10;        runInShell: true,&#10;      );&#10;      process.stdout.transform(utf8.decoder).listen((data) {&#10;        // Send log to ExecutionLog&#10;      });&#10;      process.stderr.transform(utf8.decoder).listen((data) {&#10;        // Send log to ExecutionLog&#10;      });&#10;      final exitCode = await process.exitCode;&#10;      // Send log to ExecutionLog&#10;    } catch (e) {&#10;      // Send log to ExecutionLog&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    if (_config == null) {&#10;      return const Center(child: Text('No config loaded'));&#10;    }&#10;    return ListView(&#10;      children: _config!.executions.entries.map((entry) {&#10;        final name = entry.key;&#10;        final execution = entry.value;&#10;        final controllers = _variableControllers[name] ?? {};&#10;        return ExecutionEntry(&#10;          name: name,&#10;          execution: execution,&#10;          controllers: controllers,&#10;          onRun: () =&gt; _confirmAndRunExecution(name, execution),&#10;        );&#10;      }).toList(),&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import 'dart:convert';&#10;import 'dart:io';&#10;import 'package:flutter/material.dart';&#10;import 'package:launsh/schema/config.dart';&#10;import 'package:launsh/schema/execution.dart';&#10;import 'package:launsh/execution.dart';&#10;&#10;class ExecutionList extends StatefulWidget {&#10;  final String? configFilePath;&#10;  const ExecutionList({super.key, required this.configFilePath});&#10;&#10;  @override&#10;  State&lt;ExecutionList&gt; createState() =&gt; _ExecutionListState();&#10;}&#10;&#10;class _ExecutionListState extends State&lt;ExecutionList&gt; {&#10;  Config? _config;&#10;  final Map&lt;String, Map&lt;String, TextEditingController&gt;&gt; _variableControllers = {};&#10;&#10;  @override&#10;  void didUpdateWidget(covariant ExecutionList oldWidget) {&#10;    super.didUpdateWidget(oldWidget);&#10;    if (widget.configFilePath != oldWidget.configFilePath) {&#10;      _loadConfig(widget.configFilePath);&#10;    }&#10;  }&#10;&#10;  @override&#10;  void initState() {&#10;    super.initState();&#10;    _loadConfig(widget.configFilePath);&#10;  }&#10;&#10;  Future&lt;void&gt; _loadConfig(String? path) async {&#10;    if (path == null) {&#10;      setState(() {&#10;        _config = null;&#10;        _variableControllers.clear();&#10;      });&#10;      return;&#10;    }&#10;    try {&#10;      final file = File(path);&#10;      final jsonStr = await file.readAsString();&#10;      final jsonMap = json.decode(jsonStr) as Map&lt;String, dynamic&gt;;&#10;      final config = Config.fromJson(jsonMap);&#10;      setState(() {&#10;        _config = config;&#10;        _variableControllers.clear();&#10;        for (final entry in config.executions.entries) {&#10;          _variableControllers[entry.key] = {&#10;            for (final v in entry.value.variable)&#10;              v: TextEditingController(),&#10;          };&#10;        }&#10;      });&#10;    } catch (e) {&#10;      setState(() {&#10;        _config = null;&#10;        _variableControllers.clear();&#10;      });&#10;    }&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    if (_config == null) {&#10;      return const Center(child: Text('No config loaded'));&#10;    }&#10;    return ListView(&#10;      children: _config!.executions.entries.map((entry) {&#10;        final name = entry.key;&#10;        final execution = entry.value;&#10;        final controllers = _variableControllers[name] ?? {};&#10;        return ExecutionEntry(&#10;          name: name,&#10;          execution: execution,&#10;          controllers: controllers,&#10;        );&#10;      }).toList(),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/execution_log.dart">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/execution_log.dart" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="import 'package:flutter/material.dart';&#10;&#10;class ExecutionLog extends StatefulWidget {&#10;  const ExecutionLog({super.key});&#10;&#10;  @override&#10;  State&lt;ExecutionLog&gt; createState() =&gt; _ExecutionLogState();&#10;}&#10;&#10;class _ExecutionLogState extends State&lt;ExecutionLog&gt; {&#10;  final List&lt;String&gt; _logs = [];&#10;&#10;  void addLog(String log) {&#10;    setState(() {&#10;      _logs.add(log);&#10;    });&#10;  }&#10;&#10;  @override&#10;  Widget build(BuildContext context) {&#10;    return Container(&#10;      decoration: BoxDecoration(&#10;        border: Border.all(color: Colors.grey),&#10;        borderRadius: BorderRadius.circular(8),&#10;      ),&#10;      padding: const EdgeInsets.all(8),&#10;      child: Column(&#10;        crossAxisAlignment: CrossAxisAlignment.start,&#10;        children: [&#10;          const Text('Execution Log', style: TextStyle(fontWeight: FontWeight.bold)),&#10;          const Divider(),&#10;          Expanded(&#10;            child: ListView(&#10;              children: _logs.map((log) =&gt; Text(log)).toList(),&#10;            ),&#10;          ),&#10;        ],&#10;      ),&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>